SDRAM
=====

_WIP_

Let us try to talk to the SDRAM chip of the ULX3S and OrangeCrab ! For now, this page contains
some unstructured notes, I'm currently gathering information and trying some designs. Progress
will be reported here.


- *Goal 1*: A graphic board with a 640x480 (then full HD) 24 bits RGB framebuffer
that displays a simple animated pattern generated by a
simple writer circuit (and then a FemtoRV32).

- *Goal 2*: Integrate in FemtoSOC, with full access from FemtoRV32.

Misc notes
----------
- Address: Bank, Row, Column
- Commands: open row (activate), read/write, close row (precharge _misleading: pre-charge means closing the row_)
- Refresh: either auto-refresh, or access rows
- FPGA4Fun example: ideal for graphic board (dual ported, read agent
refreshes)
- DDR RAMS
- ULX3S data sheet: 32MB SDRAM, 166MHz, 16-bit [Micron MT48LC32M16](https://www.digchip.com/datasheets/parts/datasheet/297/MT48LC32M16.php)
   - But on my own ULX3S: [ALLIANCE AS4C32M16SB-7TCN](https://www.alliancememory.com/wp-content/uploads/pdf/dram/512M%20SDRAM_%20B%20die_AS4C32M16SB-7TCN-7TIN-6TIN_Rev%201.0%20June%202016.pdf)
   - ... and there are other variants (see comments in sylefeb's Silice memory controller)

Pins
----
- clk      : 143MHz clock (7TCN series)
- cke      : clock enable (wire to 1)
- csn      : chip select (high: everything inhibited)
- command: [wen, rasn, casn]
   - wen      : write enable (read/write bit)             
   - rasn     : row address strobe (but not a strobe)     
   - casn     : column address strobe (but not a strobe)  
- a[12:0]  : address (+ 1 line to select operations burst/auto close and close in bank, close in all banks)
- ba[1:0]  : bank
- dqm[1:0] : data mask (high: suppress data I/O). One line per 8 bits.
- d[15:0]  : bidirectional data bus

Commands
--------
- nop
- load mode
- open row (activate)
- read
- write
- close row (precharge)
- refresh

State machine
-------------
[FPGA4fun](https://www.fpga4fun.com/SDRAM.html)
- Idle
- open row (activate) on transition
- Read/Write
- Close row (precharge)
- Nop


There are 'small caps' in the FPGA4fun design, read comments carefully:
 - Need to initialize CAS (Column Address Strobe) latency=2 and any valid burt mode
 - Read agent is active enough to refresh the RAM
   If these conditions are not met, we may need also:
    - a timer and 'refresh state' if reader is not active enough
    - additional 'nop' states after opening and closing a row if CAS is more than 2

Questions
---------
   - Q1: How to initialize MODE register properly ?_[OK, P. 14 of datasheet]_
   - Q2: What are the different modes ? _[OK]_
   - Q3: How to synchronize data read and video signal generation ?
   - Q4: Which one is the 'special' address line that selects burst mode ? _[OK: A10]_
   - Q5: Relation between CAS and freq ? P 15. of datasheet + table P 21. (to be understood)
   - Q6: What is auto-precharge, auto-refresh, self-refresh ?
   - Q7: At that freq, we probably need specialized FPGA blocs for latched IO pins.
   - Q8: How to implement init. sequence ? Wired ? Micro-programmed in BRAM ? CPU-controlled ? _[OK: small counter]_

Read chip datasheet (on my board: ALLIANCE AS4C32M16SB-7TCN)
------------------------------------------------------------
- Fast clock rate: 166/143 MHz
- 512 Mbits (64 MBytes): 8M words x 16 bits x 4 banks
- Modes
   - CAS Latency: 2 or 3
   - Burst length: 1,2,4,8 or full page
   - Burst type: sequential or interleaved
   - Burst stop function
- Auto refresh / self refresh
- 8192 refresh cycles / 64 ms
- Bank Activate: row address = A[12:0]
- Read/write: column address = A[9:0], auto-precharge = A[10]
- Mode register set: op code = A[..:..]
- Page 7: list of commands (19 commands !)

Mode Register Bitmap:

|BA1|BA0|A12|A11|A10|A09|A08|A07|A06|A05|A04|A03|A02|A01|A00|  
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| X | 0 | X | X | X |WBL|Tst|Tst|CAS|CAS|CAS|BT |Bst|Bst|Bst|

| Field name          | Field description                                  |
|---------------------|----------------------------------------------------|
|WBL (Write Burst Len)| 0: Burst 1: single bit                             |
|Test Mode            | 0 0 (else configs for vendor only)                 |
|CAS latency          | 010 (2 clocks) or 011 (3 clocks)                   |
|BT (Burst Type)      | 0: sequential 1: interleave                        |
|Burst len            | 000:1 001:2 010:4 011:8 111:full page (sequential) |

Answers to questions
--------------------

*Q1,Q2,Q8: MODE register and initialization sequence ?*

|BA1|BA0|A12|A11|A10|A09|A08|A07|A06|A05|A04|A03|A02|A01|A00|  
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| X | 0 | X | X | X | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 |
 
- WBL: *0: Burst* 1: single bit _I do not know what this means_
- CAS latency: *010: 2 clocks* _required by FPGA4Fun design_
- BT: *0: sequential* 1: interleave _I do not know wht this means_
- Burst len: *000: 1* _Let's keep the default for now, we'll see then, maybe 2 for 32 bits_

Initialization sequence (datasheet page 14)

- CKE goes high, DQM goes low, DQ goes Z
- wait 1 cycles
- precharge all
- wait tRP
- Mode Register Set
- wait tMRD (1 cycle)
- first command can be sent

Note: Initialization sequence described [here](https://www.hackster.io/salvador-canas/a-practical-introduction-to-sdr-sdram-memories-using-an-fpga-8f5949)
is more complicated, maybe I missed something. Taking a look at initialization sequence in Silice, Lawrie's and stffrdhrn's controllers, it seems
that the initialization sequence above can do the job (but I'm unsure it will work with all SDRAM chips). I think I'll use a simple cycles counter that
runs during the initialization sequence (and that inhibited by the global signal reset so that the chip as sufficient time at power up).

*Q3: synchronize data read and video signal generation ?*

*Q6: auto-precharge, self-refresh, auto-refresh ?
The MICRON tech sheet is easier to read. Let us see what it says:
- auto-precharge: row is precharged (closed) after burst read or burst write
- auto-refresh: addr generated by internal refresh controler. Do it one by one or in burst.
- self-refresh: retain data when the rest of the system is powered down.


References
----------
- [FPGA4fun](https://www.fpga4fun.com/SDRAM.html)
- [Lawrie](https://github.com/lawrie/ulx3s_68k/blob/master/src/sdram.v)
- [stffrdhrn](https://github.com/stffrdhrn/sdram-controller)
- [Hackaday](https://hackaday.com/2013/10/11/sdram-controller-for-low-end-fpgas/)
- [Wikipedia](https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory)
- [Hackster](https://www.hackster.io/salvador-canas/a-practical-introduction-to-sdr-sdram-memories-using-an-fpga-8f5949)
- [Chip datasheet (ALLIANCE AS4C32M16SB-7TCN)](https://www.alliancememory.com/wp-content/uploads/pdf/dram/512M%20SDRAM_%20B%20die_AS4C32M16SB-7TCN-7TIN-6TIN_Rev%201.0%20June%202016.pdf)
- [Silice](https://github.com/sylefeb/Silice/blob/master/projects/common/sdram_controller_autoprecharge_r16_w16.ice)